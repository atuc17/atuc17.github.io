---
layout: post
title: Phụ lục 3 - Tính nghịch đảo modulo số nguyên tố và đa thức tối giản
categories: [cryptography]
---
Tiếp nối phụ lục 2, phần này trình bày thuật toán Euclid mở rộng là thuật toán chuyên dùng để tính nghịch đảo trên GF(p) và GF(2<sup>n</sup>). 

Code sử dụng trong phần này là python 3 và thư viện Sagemath.

## 1. Thuật toán Euclid chuẩn

Ký hiệu gcd(a, b) là ước chung lớn nhất của 2 số nguyên a, b. Thuật toán Euclid tìm ước chung lớn nhất của a, b theo nhận xét gcd(a, b) = gcd(b, a % b). Chứng minh của thuật toán này có trên wikipedia hay nhiều trang về toán khác nên mình không chứng minh lại ở đây.

Code của thuật toán:

```python
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a
```

## 2. Thuật toán Euclid mở rộng

Thuật toán Euclid mở rộng ngoài việc tìm được ước chung lớn nhất gcd(a, b) của a, b thì còn tìm được 2 số nguyên x, y thỏa mãn: ax + by = gcd(a, b) (phương trình Diophantus).

Mã giả của thuật toán:

```python
def xgcd(a, b):
    x0, x1 = 1, 0 # Khởi tạo
    y0, y1 = 0, 1 # Khởi tạo
    while b: # giống thuật toán Euclid chuẩn
        q = a div b
        a, b = b, a - q * b # Chính là a, b = b, a % b

        x0, x1 = x1, x0 - q * x1 # Lấy q từ a, b để tính lại x0, x1
        y0, y1 = y1, y0 - q * y1 # Lấy q từ a, b để tính lại y0, y1
    return a, x0, y0
    # a là ước chung lớn nhất như thuật toán Euclid chuẩn
    # x0, y0 là 2 số thỏa mãn ax + by = gcd(a, b)
```

Demo với a = 63 và b = 25. 

![xgcd](/assets/crypto/xgcd.jpg)

Kết quả trả về 1, 2 và -5. Thử lại ta thấy 63 * 2 + 25 * (-5) = 1 = gcd(63, 25).

**Áp dụng tìm nghịch đảo**: giả sử ta muốn tìm nghịch đảo của số a trong modulo n, tức là tìm số b sao cho $$ab \equiv 1 \; mod n$$. Sử dụng thuật toán Euclid mở rộng với tham số là a và n thì ta có 2 số u, v thỏa $$au + vn = gcd(a, n)$$.

Nếu ta modulo 2 vế phương trình trên cho n, ta được $$au \equiv gcd(a, n) \; mod n$$. Nghĩa là, để tồn tại nghịch đảo thì gcd(a, n) phải bằng 1 và khi đó b chính là số u vừa tính được modulo cho n (vì u có thể âm).

**Note**: thuật toán Euclid mở rộng tìm ra 1 nghiệm x, y của phương trình ax+by=gcd(a, b), nhưng thực tế phương trình này có vô số cặp nghiệm x, y có liên hệ với nhau. Mình sẽ không trình bày ở đây mà để vào dịp khác.

## 3. Thuật toán Euclid mở rộng trên đa thức

Phần này sử dụng thư viện Sagemath hỗ trợ sẵn đa thức để tiện việc code và tính toán.

Để khai báo 1 trường hữu hạn $$GF(p)$$ trong Sagemath và tạo 1 *vành* đa thức **R** (Sagemath sử dụng *vành* đa thức thì không phải lúc nào cũng có nghịch đảo) trên $$GF(p)$$ ta dùng lệnh:

```python
p = GF(2) # p = 2
R.<x> = PolynomialRing(p) # đa thức biến x, trên trường GF(2)
```

Để tạo đa thức $$f(x) = x^5+x^3+x^2+1$$ và $$g(x) = x^2+1$$ trên Sagemath, ta chỉ việc dùng lệnh: 

```python
f = R(x^5+x^3+x+1)
g = R(x^2+1)
```

Do Sagemath đã định nghĩa các toán tử cộng, trừ, nhân, chia trên đa thức, nên code của thuật toán Euclid và thuật toán Euclid mở rộng trong trường đa thức y hệt bên trên.

Ví dụ mình có thể tính đa thức h mà $$f(x) = x^2+1$$ và $$g(x) = x+1$$ đều chia hết.

```python
print(gcd(R(x^2+1), R(x+1)))
```

Màn hình xuất ra x+1, kiểm tra lại ta thấy f(x) và g(x) đều chia hết. 

Giả sử với p = 2, n = 3 ở phụ lục 2, ta có $$W_{pm} = \{0, 1, x, x+1, x^2, x^2+1, x^2+x, x^2+x+1\}$$

Dùng thuật toán Euclid mở rộng ta tính được nghịch đảo tất cả phần tử của $$W_{pm}$$ trong đa thức $$m(x) = x^3+x+1$$ (là đa thức tối giản) như sau:

| Đa thức | Nghịch đảo tương ứng | 
| 0 | Không có nghịch đảo |
| 1 | 1 |
| x | x<sup>2</sup> + 1 |
| x + 1 | x<sup>2</sup> + x|
| x<sup>2</sup> | x<sup>2</sup> + x + 1 |
| x<sup>2</sup> + 1 | x |
| x<sup>2</sup> + x | x + 1 |
| x<sup>2</sup> + x + 1 | x<sup>2</sup> |
